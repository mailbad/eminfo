#!/usr/bin/env bash
#
#
# =======================================================================================
#  This File Contains Global Variables and Public Functions Used by EMINFO and Plugins. 
# =======================================================================================
#
#



# BASE_DIR DEF
[ -z ${BASE_DIR} ] && {
  	path=$( cd $(dirname $0) && pwd)
  	BASE_DIR=${path%/*}
}




####################################
#				   #
#  --*--< Global Variables >--*--  #
#			           #
####################################

# VER DEF
EMINFO_VERSION="1.0.0-beta2"

# DIR DEF
BIN_DIR="${BASE_DIR}/bin"
CONF_DIR="${BASE_DIR}/conf"
DOC_DIR="${BASE_DIR}/doc"
HANDLER_DIR="${BASE_DIR}/handler"
OPT_DIR="${BASE_DIR}/opt"
TOOL_DIR="${BASE_DIR}/tool"
PLUGIN_DIR="${BASE_DIR}/plugin"
INNER_DIR="${PLUGIN_DIR}/.inner"
TMP_DIR="${BASE_DIR}/tmp"
RUN_DIR="${TMP_DIR}/run"
LOG_DIR="${BASE_DIR}/log"
BACK_DIR="${LOG_DIR}/backup"
SNAPSHOT_DIR="${LOG_DIR}/snapshot"

# SH DEF
PRECHECK_SH="${BIN_DIR}/precheck"
UPDATE_SH="${BIN_DIR}/update"
REPORT_SH="${BIN_DIR}/report"
CHECKCONF_SH="${BIN_DIR}/checkconf"
POSTLOG_SH="${HANDLER_DIR}/postlog"
TAKESNAP_SH="${HANDLER_DIR}/takesnap"
SENDMAIL="${HANDLER_DIR}/sendmail"
SENDEMAIL="${OPT_DIR}/sendEmail"
MAKEDIR_SH="${BIN_DIR}/makedir"

# PERL UTIL DEF
PLUTIL="${BIN_DIR}/util.pl"

# LOG DEF
EMINFO_LOG="${LOG_DIR}/eminfo.log"
INNER_LOG="${LOG_DIR}/inner.log"
PRECHECK_LOG="${LOG_DIR}/precheck.log"
POSTLOG_LOG="${LOG_DIR}/postlog.log"
TAKESNAP_LOG="${LOG_DIR}/takesnap.log"
UPDATE_LOG="${LOG_DIR}/update.log"
SENDMAIL_LOG="${LOG_DIR}/sendmail.log"

# CFG DEF
CONFIG_FILE="${CONF_DIR}/eminfo.ini"

# INC DEF
INCLUDE_FILE="${BIN_DIR}/include"

# PID DEF
PID_FILE="/var/run/eminfo.pid"

# TMP FILE DEF
TMP_LASTRUN="${TMP_DIR}/.lastrun.dat"
TMP_NEXTRUN="${TMP_DIR}/.nextrun.dat"
TMP_REPEAT="${TMP_DIR}/.repeat.dat"
TMP_STATUS="${TMP_DIR}/.status.dat"

# OTHER FILE DEF
PINYIN_FILE="${OPT_DIR}/pinyin.txt"


### POSTDATA SPLIT
SPLIT="#EMINFO#"


### PLUGIN BASE CONFIG NAME
ARRAY_BASE_CONFIG=(
  enable
  comment
  frequency
  exec_tmout
  maxerr_times
  take_snapshot_type
  mail_notify_type
  post_notify_type
  mail_receviers
  attach_snap_mail
  auto_handle_type
  auto_handler
  debug
)

### PLUGIN RETRUN CODE MAPS
ARRAY_RCSTATUS_MAPS=(
  0 succ
  1 warn
  2 crit
  3 unkn
  4 noop
)


####################################
#				   #
#  --*--< Public Functions >--*--  #
#				   #
####################################



# Terminal color
echo_green() {
  local content=$*
  echo -e "\033[1;32m${content}\033[0m\c "
}
echo_yellow() {
  local content=$*
  echo -e "\033[1;33m${content}\033[0m\c "
}
echo_red() { 
  local content=$* 
  echo -e "\033[1;31m${content}\033[0m\c "
}

# HTML color
html_green() {
  local content=$*
  echo -e "<strong><font color=green>${content}</font></strong> \c "
}
html_yellow() {
  local content=$*
  echo -e "<strong><font color=yellow>${content}</font></strong> \c "
}
html_red() {
  local content=$*
  echo -e "<strong><font color=red>${content}</font></strong> \c "
}

# Random Number in specified range
# Usage:	random_num  min  max
#
random_num() {
  local min=$1 max=$2 tmp=$(echo "$2-$1" | bc 2>&-) base=$(date +%N%s)
  echo "${base} % ${tmp} + ${min} " | bc 2>&-
}

# $1 contains $2 or not
# Usage:	sub_str "strings" "str"
#
sub_str() {  
  [ "${1#*$2*}" == "$1" ] && echo no || echo yes  
}

# Write log
# Usage1:	1: set {_LOG} and ${_DEBUG} before you call this function.
# Usage2:	2: -f path/to/log/file     Note: this pattern will ignore ${_DEBUG} flag.
# Example1:	export _LOG=/tmp/log DEBUG=1 && write_log any stuff you want to log && unset _LOG
# Example2:	write_log -f /tmp/log  any stuff you want to log.
#
write_log() {
  local logfile=  content=
  [ "$1" == "-f" ] && {
	logfile="$2" ; shift 2
	content=$*
  } || {
  	[ "${_DEBUG}" != "1" ] && return 0
  	[ -z "${_LOG}" ] &&  logfile="${EMINFO_LOG}" || logfile="${_LOG}"
 	content=$*
  }
  echo "$(date +%s)" "$(date +%F_%T)" "${content}"  >> ${logfile} 2>&-
}

# Convert multi-link-path to real-path ( using python os.path.realpath )
# Usage:	py_conv_2realpath /path/to/somewhere
# Example:      py_conv_2realpath /link_1/link_2/link_3/link_filenam
#
py_conv_2realpath() {
  local f=$1  result=
  result=$( python -c "import os; print os.path.realpath('${f}')" 2>&- )
  echo -e "${result}"
}

# Convert multi-link-path to real-path
# Return: 	0 1 2 		realpath | relative link path | broken path
# Usage:	conv_2realpath  /path/to/somewhere
# Example:	conv_2realpath  /link_1/link_2/link_3/link_filename
#
# Sorry, Can NOT deal with: non-absolute link
#
conv_2realpath() {
  local f=$1
  local org="${f}"

  ### deal with broken path
  [ ! -e "${f}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 conv_2realpath broken path:"\
		"[${f}] broken at: [${f}]";
	return 2
  }
  
  until [ ! -L "${f}" ] 
  do
	f=$(readlink "${f}")
  done 

  local d= b=
  local arr=()

  b=$(basename "${f}")
  arr=( ${arr[@]} ${b} )
  d=$(dirname "${f}")
  until [ "${d}" == "/" ]; do
  	if [ -L "${d}" ]; then
		d=$(readlink "${d}")
  	else
		### deal with non-absolute path
		[ "${d}" == ".." -o "${d}" == "." -o "$(echo -e "${d}" |grep -E -o "\.\.\/|\.\/")" != "" ] && {
			write_log -f "${EMINFO_LOG}" "E0000000 conv_2realpath relative link path:"\
				"[${d}]";
			return 1
		}
		### deal with broken path
		[ ! -d "${d}" ] && {
			write_log -f "${EMINFO_LOG}" "E0000000 conv_2realpath broken path:"\
				"[${d}] broken at: [${d}]";
			return 2
		}
		b=$(basename "${d}")
		arr=( ${arr[@]} ${b} )
		d=$(dirname "${d}")
  	fi
  done

  for ((i=${#arr[@]};i>0;i--))
  do
	echo -ne "${arr[$i]}/"
  done
  echo -e "${arr[0]}"

  return 0
}

# According to input pidfile, output process state.
# Usage:	check_ps_on_pid_file  {pid_file}
# Return: 	0 1 2 3  ==>  Running | Missing arguments | Dead but pid file exists | Dead
#
check_ps_by_pid_file() {
  local pid_file=$1  pid=
  [ -z "${pid_file}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 check_ps_by_pid_file error:"\
		 "missing arguments, fpid=[${fpid}]";
	return 1
  }
  [ -f "${pid_file}" -a -s "${pid_file}" ] && {
  	read line < ${pid_file}
	for x in `echo ${line}`; do
  		[ -z "${x//[0-9]/}" -a -d "/proc/${x}" ] && pid="${pid} ${x}"
  	done
  	[ ! -z "${pid//[ ]}" ] && return 0 || return 2
  }
  return 3
}

# According to input ppid, search all of son pids, output by reverse order.
# Usage:        get_children_pid_by_pid  {father_pid}
# Example:      get_children_pid_by_pid  1876
#
get_children_pids_by_pid() {
  local father_pid=$1
  local array_result=()
  # if null pstree will output all pids.
  [ -z "${father_pid}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_children_pids_by_pid error:"\
		"missing arguments, father_pid=[${father_pid}]";
	return 2
  }
  if [ -z "${father_pid//[0-9]}" ]; then
	# array_result=$( ps --ppid ${father_pid} -o pid  | tail -n +2 | tr '\n\r' ' ' )    ### Not Recurse
	array_result=( $(pstree -p ${father_pid} |\
			 grep -E -o "\([0-9]+\)" |\
			 tr -d '[\(\)]' | tail -n +2 |\
			 tr '\n\r' ' ') )
  else
	write_log -f "${EMINFO_LOG}" "E0000000 get_children_pids_by_pid error:"\
		"input father_pid must be interger: [${father_pid}]";
	return 1
  fi
  
  for ((i=${#array_result[@]}-1;i>=0;i--))  ; do
     echo -n "${array_result[$i]} "
  done
  unset array_result
}

# Check the file is plugin config file or not
# Conditions: 
#   1. filename like {plugin-name}.ini
#   2. headline of file like  [plugin-name]
#
is_plugin_configfile(){
  local filepath=$1
  local filename="${filepath##*/}"
  local pname=$(echo "${filename}" | perl -ne 'if (m/\A(.+)\.ini\Z/i){print "$1"};' 2>&-)
  local hname=$(head -n1 "${filepath}" | perl -ne 'if(m/\A\s*\[\s*(.+)\s*\]\s*/){print "$1"};' 2>&-)
}

# List all section name.
# Note: 	blank space will be trimed
#
list_all_section() {
  # Do NOT pass non-english such as chinese input to command sed, which will lead to hangup in some circumstances.
  cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
  	sed -e '/^\[.*\]$/!d;/^\[[ \t]*\]$/d;s/^\[//;s/\]$//;' |\
  	tr '\r\n' ' ';
}

# List all registered plugins exclude inners.  		
# Note: 	blank space will be trimed
#
list_plugin_section() {
  # Do NOT pass non-english such as chinese input to command sed, which will lead to hangup in some circumstances.
  cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
	sed -e '/^\[.*\]$/!d; /^\[eminfo_.*\]$/d; /^\[[ \t]*\]$/d; s/^\[//; s/\]$//;' |\
	tail -n +3 | tr '\r\n' ' ';
}

# List all inner plugins.		
# Note: 	blank space will be trimed
#
list_inner_plugin_section() {
  # Do NOT pass non-english such as chinese input to command sed, which will lead to hangup in some circumstances.
  cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
	sed -e '/^\[eminfo_.*\]$/!d; s/^\[//; s/\]$//;' |\
	tr '\r\n' ' ';
}

# List single section's key name
#
list_section_keys(){
  local section=$1  result=
  [ -z "${section}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 list_section_keys error:"\
		"missing section name";
        return 1
  }
  result=$(cat ${CONFIG_FILE} | tr '\t' ' ' |\
		awk -F "=" '\
			($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next} \
			( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit} \
			(k==1 && x==1 && $0!~/^[ \t]*$/ && $0!~/^[ \t]*;/){print $1}' |\
		sed -e 's/^[ \t]*//; s/[ \t]*$//; s/^\"//; s/\"$//')
  echo -e "${result}"
}

# According to input plugin-name, output matched plugin-name in config file.
# Example:	read_eminfo_section  check_sysload
# Return:	0 1 2 3 :  OK | Missing arguments | ${CONFIG_FILE} empty / not exist | Null
#
read_eminfo_section(){
  local section=$1  value=
  if [ -z "${section}" ]; then 
	write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_section error:"\
		"missing arguments, section=[${section}]";
	return 1
  else
	if [ ! -f "${CONFIG_FILE}" -o ! -s "${CONFIG_FILE}" ]; then
		write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_section error:"\
			"config file not exists or empty.";
		return 2
	else
		value=$(cat ${CONFIG_FILE} |\
			grep -E -v "^[ \t]*;" | tr -d ' \t' |\
			sed -e '/^\['${section}'\]$/!d; s/^\[//; s/\]$//;')
		if [ -n "${value}" ]; then
			echo "${value}" 
			return 0
		else
			# write_log -f "${EMINFO_LOG}" E0000000 read_eminfo_section error: "[${section}]"  return NULL.
			return 3
		fi
	fi
  fi
}

# According to input plugin-name config-name, output matched config-value in config file.
# Usage:  	read_eminfo_config {plugin-name} {config-name}
# Example:  	read_eminfo_config check_sysload  enable
# Return:	0 1 2 3 :  OK | Missging arguments | ${CONFIG_FILE} empty / not exist | Null
#
read_eminfo_config(){
  local section=$1  key=$2  value=
  if [ -z "${section}" -o -z "${key}" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
	return 1
  else
	if [ -f "${CONFIG_FILE}" -a -s "${CONFIG_FILE}" ]; then
		###  Notice:  \s NOT match : []space
  		value=$( cat ${CONFIG_FILE} | tr '\t' ' ' |\
			awk -F "=" '\
				($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
				( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
				( k==1 && x==1 && $1~/^'${key}'\>/ ){$1="";print;exit}' |\
			 sed -e 's/^[ \t]*//; s/[ \t]*$//; s/^\"//; s/\"$//' )
		if [ -n "${value}" ]; then
			echo "${value}" && return 0 
		else
			# this may lead to plenty of log records in {EMINFO_LOG}
			# write_log -f "${EMINFO_LOG}" E0000000 read_eminfo_config error: "[${section}.${key}]" return NULL.
			return 3
		fi
	else
		write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_config error:"\
			"config file not exists or empty.";
		return 2
	fi
  fi
}

# According to exist plugin-name/key and input value, update matched value in config file.
# Usage:	update_eminfo_config {plugin-name} {config-name} {value}
# Example:	update_eminfo_config check_sysload enable no
# Return:	
# 0 : Update OK
# 1 : Update ERROR
# 2 : No Need, Nothing to do (nower value equals what you want to set)
# 3 : Missging arguments
# 4 : ${CONFIG_FILE} empty / not exist 
# 5 : [section].key not exist
# LogFlag:      CHNG0000
# 
update_eminfo_config() {
  local section=$1 key=$2 ; shift 2 ; local value=$*
  local errinfo=
  if [ -z "${section}" -o -z "${key}" -o -z "${value}" ]; then
        write_log -f "${EMINFO_LOG}" "E0000000 update_eminfo_config error:"\
		"missing arguments, section=[${section}] key=[${key}] value=[${value}]";
        return 3
  else
	if [ -f "${CONFIG_FILE}" -a -s "${CONFIG_FILE}" ]; then
  		local linenum=$( cat ${CONFIG_FILE} | tr '\t' ' ' |\
				 awk -F"=" '\
					($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
					( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
					( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
  		if [ -z "${linenum//[ ]}" ]; then
			write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config notice:"\
				"section=[${section}] key=[${key}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_eminfo_config "${section}" "${key}")
			if [ "${value}" != "${nowvalue}" ]; then
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to change as [${value}]"
			else
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					"line-number=[${linenum}], nower value=[${nowvalue}],"\
					"no need to change as [${value}], nothing to do."
				return 2
			fi
                        ### '"${value}"' is important, if ${value} is multi part or cotains invalid chars, sed won't complain
                        ### '${value}' is wrong.
			### sed command c to replace the whole line.
			errinfo=$(\
			    sed -i ''${linenum}'c'${key}' = '"${value}"'' "${CONFIG_FILE}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config change"\
					"section=[${section}] key=[${key}] value=[${value}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config error:"\
					"section=[${section}] key=[${key}] value=[${value}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${EMINFO_LOG}" "E0000000 update_eminfo_config error:"\
			"config file not exists or empty.";
		return 4
	fi
  fi
}

# According to exist plugin-name and input key/value , add key = value into config file.
# Usage:        add_eminfo_config {plugin-name} {config-name} {value}
# Example:      add_eminfo_config check_sysload enable no
# Return:       
# 0 : ADD OK
# 1 : ADD ERROR
# 2 : No Need, Nothing to do (key already exist)
# 3 : Missging arguments
# 4 : ${CONFIG_FILE} empty / not exist 
# 5 : [section] not exist
# LogFlag:      ADDC0000
# 
add_eminfo_config() {
  local section=$1 key=$2 ; shift 2 ; local value=$*
  local errinfo=
  if [ -z "${section}" -o -z "${key}" -o -z "${value}" ]; then 
        write_log -f "${EMINFO_LOG}" "E0000000 add_eminfo_config error:"\
                "missing arguments, section=[${section}] key=[${key}] value=[${value}]";
        return 3
  else 
	if [ -f "${CONFIG_FILE}" -a -s "${CONFIG_FILE}" ]; then
		local section_linenum=$( cat ${CONFIG_FILE} | tr '\t' ' ' |\
					awk '($0~/^ *\[ *'${section}' *\] *$/){print NR;exit;}' )
		if [ -z "${section_linenum//[ ]}" ]; then
			write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config notice:"\
				"section=[${section}] not found in config file."
                        return 5
		else
			local flag=0
			for k in `list_section_keys "${section}"`
			do
				if [ "${key}" != "${k}" ]; then
					continue
				else
					flag=1; break
				fi
			done
			if [ "${flag}" == "0" ]; then
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config notice:"\
                                        "key=[${key}] for section=[${section}] not found in config file,"\
                                        "trying to add config [${key}] for [${section}]"\
					"under line [${section_linenum}]"
			else
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config notice:"\
                                        "key=[${key}] for section=[${section}] already exists in config file,"\
                                        "no need to add config [${key}] for [${section}], nothing to do."
				return 2
			fi
			### '"${value}"' is important, if ${value} is multi part or cotains invalid chars, sed won't complain
			### '${value}' is wrong.
			### sed command a to add newline under specified line.
			errinfo=$(\
				sed -i ''${section_linenum}'a'${key}' = '"${value}"'' "${CONFIG_FILE}" 2>&1 1>/dev/null)
                        if [ "$?" == "0" ]; then 
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config add"\
                                        "config [${key} = ${value}] for section [${section}] under [${section_linenum}]"\
                                        "success"
                                return 0
                        else 
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config error: [${errinfo}]" 
                                return 1
                        fi
		fi
	else
                write_log -f "${EMINFO_LOG}" "E0000000 add_eminfo_config error:"\
                        "config file not exists or empty.";
                return 4
	fi
  fi
}

# According to exist plugin-name and input key , delete plugin's key from config file.
# Usage:        del_eminfo_config {plugin-name} {config-name}
# Example:      del_eminfo_config check_sysload enable
# Return:
# 0 : DEL OK
# 1 : DEL ERROR
# 2 : No Need, Nothing to do (key already not exist)
# 3 : Missging arguments
# 4 : ${CONFIG_FILE} empty / not exist 
# 5 : [section] not exist
# LogFlag:	DELC0000
#
del_eminfo_config() {
  local section=$1 key=$2
  local errinfo=
  if [ -z "${section}" -o -z "${key}" ]; then
        write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
        return 3
  else
	if [ -f "${CONFIG_FILE}" -a -s "${CONFIG_FILE}" ]; then
  		local linenum=$( cat ${CONFIG_FILE} | tr '\t' ' ' |\
				 awk -F"=" '\
					($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
					( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
					( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
  		if [ -z "${linenum//[ ]}" ]; then
			write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config notice:"\
				"section=[${section}] key=[${key}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_eminfo_config "${section}" "${key}")
			local flag=0
			for k in `list_section_keys "${section}"`
			do
				if [ "${key}" != "${k}" ]; then
					continue
				else
					flag=1; break
				fi
			done
			if [ "${flag}" == "1" ]; then
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to delete config [${key}]"
			else
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config notice:"\
					"section=[${section}] key=[${key}] not found in config file,"\
					"no need to delete it, nothing to do."
				return 2
			fi
			### sed command d to delete the whole line.
			errinfo=$(\
			    sed -i ''${linenum}'d' "${CONFIG_FILE}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config delete"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config error:"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config error:"\
			"config file not exists or empty.";
		return 4
	fi
  fi
}

# Get plugin status    config-name:  enable
# Note: if returned config-value is invalid, return no
#
get_enable() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_enable error: missing plugin name";
	return 1
  }
  result=$(read_eminfo_config ${plugin_name} enable)
  [ -z "${result//[ ]}" ] && result=$(read_eminfo_config plugin_default enable)

  # check valid or not
  [ -z "${result//[ ]}" ] && {
	result="no"
  } || {
  	[ "${result}" != "yes" -a "${result}" != "no" ] && result="no"
  }
  echo "${result}"
}

# Get plugin debug	config-name:  debug
# Note: if returned config-value is invalid, return yes
#
get_debug() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_debug error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} debug)
  [ -z "${result//[ ]}" ] && result=$(read_eminfo_config plugin_default debug)
 
  # check valid or not
  [ -z "${result//[ ]}" ] && {
        result="yes"
  } || {
        [ "${result}" != "yes" -a "${result}" != "no" ] && result="yes"
  }
  echo "${result}"
}

# Get plugin attach_snap_mail	config-name:  attach_snap_mail
# Note: called by script: bin/sendmail
# Note: if returned config-value null or invalid, return yes
#
get_attach_snap_mail() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_attach_snap_mail error: missing plugin name";
        return 1
  }

  result=$(read_eminfo_config ${plugin_name} attach_snap_mail)
  [ -z "${result//[ ]}" ] && result=$(read_eminfo_config plugin_default attach_snap_mail)
  # check null or invalid or not
  [ -z "${result//[ ]}" ] && {
 	result="yes"
  } || {
  	[ "${result}" != "yes" -a "${result}" != "no" ] && result="yes"
  }
  echo "${result}"
}

# Get plugin frequency    config-name: frequency
# Note: if returned config-value is invalid, return 30min
#
get_frequency() {
  local plugin_name=$1  result=  value=   min=30
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_frequency error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} frequency)
  [ -z "${result}" ] && result=$(read_eminfo_config plugin_default frequency)

  # check valid or not
  value=$( conv_time2sec "${result}" )
  if [ "${value}" == "invalid" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 get_frequency on"\
		"[${plugin_name}]: return is invalid:"\
		"[${result}] ==> auto set to 30min.";
	result="30min"
  elif [ ! -z "${value}" -a -z "${value//[0-9]}" ]; then
	[ "$(echo "${value} < ${min}" | bc 2>&-)" == "1" ] && {
		write_log -f "${EMINFO_LOG}" "E0000000 get_frequency on"\
			"[${plugin_name}]: return [${result}] is smaller than minimum"\
			"==> auto set to 30sec";
		result="30sec"
	}
  fi
  echo "${result}"
}

# Get plugin execution timeout      config-name:  exec_tmout
# Note: if returned config-value is invalid. return 10min
# 
get_exec_tmout() {
  local plugin_name=$1  result=  value=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_exec_tmout error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} exec_tmout)
  [ -z "${result}" ] && result=$(read_eminfo_config plugin_default exec_tmout)

  # check valid or not
  value=$( conv_time2sec "${result}" )
  [ "${value}" == "invalid" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_exec_tmout on [${plugin_name}]:"\
		"return is invalid: [${result}]"\
		"==>auto set to 10min.";
        result="10min"
  }
  echo "${result}"
}

# Get plugin mail receviers	config-name:  mail_receviers
# called by script bin/sendmail
# Note: if returned email address is empty. return "root_bbk@126.com"
#
get_mail_receviers() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_mail_receviers error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} mail_receviers)
  [ -z "${result}" ] && result=$(read_eminfo_config plugin_default mail_receviers)

  if [ -f "/${result##*file:}" -a -s "/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "/${result##*file:}")
  elif [ -f "${BASE_DIR}/${result##*file:}" -a -s "${BASE_DIR}/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "${BASE_DIR}/${result##*file:}")
  else
        [ -z "${result}" ] && result="root_bbk@126.com"  ### set default whatever.
  fi
  echo -e "${result}"
}

# Get plugin comment		config-name:  comment
# Note: if returned config-value is empty. return "Eminfo Plugin"
#
get_comment() {
  local plugin_name=$1  result=  default="Eminfo Plugin"
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_comment error: missing plugin name";
	return 1
  }
  result=$(read_eminfo_config ${plugin_name} comment)
  result=${result//[!0-9a-zA-Z_. ]}
  [ -z "${result}" ] && result=$(read_eminfo_config plugin_default comment)
  result=${result//[!0-9a-zA-Z_. ]}
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get global name		config-name:  name
# Note: if returned config-value is empty. return "Linux Server"
#
get_global_name() {
  local result=  default="Linux Server"
  result=$( read_eminfo_config global name )
  result=${result//[!0-9a-zA-Z_. ]}
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get plugin max repeat errtimes	config-name:  maxerr_times
# Note: if returned config-value is invalid. return 1
#
get_maxerr_times() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_maxerr_times error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} maxerr_times)
  [ -z "${result}" ] && result=$(read_eminfo_config plugin_default maxerr_times)

  # check valid or not ==> ( 0 is invalid )
  [ -z "${result}" -o ! -z "${result//[1-9]}" ] && result=1  # set default whatever.
  echo "${result}"
}

# Get plugin's xxxx_action_type value.		
# allowed action_type ==> [ take_snapshot_type | mail_notify_type | post_notify_type | auto_handle_type ]
# Usage:      get_action_type  plugin-name  xxxx_action_type
# Example:	get_action_type  check_sysload mail_notify_type
# Note: invalid values will be ignored, only return valid values.
# Note: duplication items will be removed.
# Return:  1: plugin_name or action_type empty  2: action_type invalid
#
get_action_type() {
  local plugin_name=$1  action_type=$2
  local result=  output=  item=
  local valid_list=" crit warn unkn succ tmout all none default "
  [ -z "${plugin_name}" -o -z "${action_type}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_action_type error:"\
		"missing plugin_name or action_type : [$*]";
        return 1
  }
  [ "${action_type}" != "take_snapshot_type" -a "${action_type}" != "mail_notify_type" -a "${action_type}" != "post_notify_type" -a "${action_type}" != "auto_handle_type" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_action_type error:"\
		"action_type: [${action_type}] is invalid,"\
		"only [ take_snapshot_type/mail_notify_type/post_notify_type/auto_handle_type ] is acceptable.";
	return 2
  }

  ### read values
  result=$(read_eminfo_config ${plugin_name} ${action_type})
  [ -z "${result}" ] && result=$(read_eminfo_config plugin_default ${action_type})

  ### unfolder [all|default|none] and remove invalid values.
  for item in `echo "${result}"`
  do
	if [ "$(echo -e "${valid_list}"|grep -E -o -w "${item}")" == "${item}" ]; then  ### item valid
		case "${item}" in
		"all")
			output="${output} crit warn unkn succ tmout"	;;
		"default")
			### auto_handle_type ==> "default" means "none"
			if [ "${action_type}" == "auto_handle_type" ]; then
				output="none"	### break while "none"
				break
			else
				output="${output} crit warn unkn tmout"
			fi					;;
		"none")
			output="none"  ### break while "none"
			break						;;
		*)
			output="${output} ${item}"
		esac	
	fi
  done

  ### remove duplication items.
  output=$(echo "${output}" | awk -vRS="[\n ]" -vORS=" " '!a[$0]++')
  echo "${output}"
}

# Take action or not
# Argument 1:  plugin-name
# Argument 2:  action_type => take_snapshot_type mail_notify_type post_notify_type auto_handle_type
# Argument 3:  event	=> 0 1 2 3 4 tmout
# Example:	take_action_ornot  check_sysload mail_notify_type 3
# Example:	take_action_ornot  check_v4_ps post_notify_type 0
# Example:	take_action_ornot  check_cpu_usage take_snapshot_type tmout
# 
take_action_ornot() {
  local plugin_name=$1  action_type=$2  event=$3
  local result=
  local valid_list=" crit warn unkn succ tmout all none default "
  [ -z "${plugin_name}" -o -z "${action_type}" -o -z "${event}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 take_action_ornot error:"\
		"missing plugin_name or action_type or event : [$*]";
        return 1
  }
  
  ### 1. read plugin_name action_type
  local action_type_config=$(get_action_type ${plugin_name} ${action_type})

  ### 2. event in actinon_type or not ? 
  local status=
  if [ "${event}" == "tmout" ]; then  ### 2.1 process event: tmout 
	[ "$(echo -e "${action_type_config}"|grep -E -o -w "${event}")" == "${event}" ] && {
		result="yes"
	} || {
		result="no"
	}
  else
  	for ((i=0;i<=${#ARRAY_RCSTATUS_MAPS[@]}-1;i++))  ### 2.2 process event: return_code
  	do
		[ "${ARRAY_RCSTATUS_MAPS[${i}]}" == "${event}" ] && {
			local i2=$((${i}+1))
			status=${ARRAY_RCSTATUS_MAPS[${i2}]}
			# echo "${i} ${i2} ${ARRAY_RCSTATUS_MAPS[${i2}]} ${action_type_config}"
			[ "$(echo -e "${action_type_config}"|grep -E -o -w "${status}")" == "${status}" ] && {
				result="yes"
			} || {
				result="no"
			}
			break
		}
  	done
	[ -z "${result}" ] && result="no"   ### if not matched, return no
  fi
  echo "${result}"
}

# Convert timelong to seconds
# Output:	seconds	| invalid
# Example:	conv_time2sec  30sec | 30seconds | 30min | 1hour | 1day | 2week | 3month | 4year | 2day5hour54sec
#
conv_time2sec(){
  local timelong=$1 result=
  local now=$(date +%s)
  local after=$(date -d "+${timelong}" +%s 2>&-)
  if [ ! -z "${after}" -a -z "${after//[0-9]}" ]; then
	result=$(echo "${after//[!0-9]} - ${now}" | bc 2>&-)
  else
	write_log -f "${EMINFO_LOG}" "E0000000 conv_time2sec error:"\
		"input invalid: ${timelong}";
	result="invalid"
  fi
  echo "${result}"
}

# Read each part of plugin output
# Usage:	read_output  part_num  "${content}"   
# Note:  	part_num ~ [1-6]
# Example:	read_output  2  "{level}:{type}:{title | summary | details: item1. ### item2. ### item3. ### }"
# Example:	read_output  6  "{level}:{type}:{title | summary | details: item1. ### item2. ### item3. ### }"
# 
read_output(){
  local part=$1 ; shift
  local strings=$*  result=

  case "${part}" in
  1|2|3|4|5|6)
	result=$( ${PLUTIL} part_pstr_output "$part" "${strings}" 2>&1 )
  	echo "${result}"
	# for debug as following.
	# write_log -f "${EMINFO_LOG}" "E0000000 read_output OK: wanted part number [$part]:[${result}]";
	;;
  *)
	write_log -f "${EMINFO_LOG}" "E0000000 read_output error: wanted part number invalid: ${part}";
	return 2	
	;;
  esac
}

# Convert plugin output to html mailbody
# Output: 	path of html mailbody
# Usage:        conv_output2mailbody  "${content}"
# Example:	conv_output2mailbody  "{level}:{type}:{title | summary | details: item1. ### item2. ### item3. ### }"
#
conv_output2mailbody() {
  local strings=$* level= title= summary= details= mailbody=

  level=$(read_output 1 "${strings}" | tr '[a-z]' '[A-Z]')
  title=$(read_output 4 "${strings}")
  summary=$(read_output 5 "${strings}")
  details=$(read_output 6 "${strings}")

  mailbody="$(gen_tmpfile mailbody)"
  {
  echo "$(html_green "Notify_Type:")  &nbsp;&nbsp;&nbsp;&nbsp; ${level} <br><br>"
  echo "$(html_green "Title:")  &nbsp;&nbsp;&nbsp;&nbsp; ${title} <br><br>"
  echo "$(html_green "Summary:") &nbsp;&nbsp;&nbsp;&nbsp; ${summary} <br><br>"
  echo "$(html_green "Details:") <br><br>"
  # echo "${details}" | awk -F"###" '{ for(i=1;i<=NF;i++) {printf "%s<br>\n",$i} }'
  echo "${details}" | sed -e 's/###/<br>\n/g';
  } >> "${mailbody}"
  rc=$?
  if [ "${rc}" == "0" ]; then
	write_log -f "${EMINFO_LOG}" "00000000 convert output to mailbody file success:"\
		"[${mailbody}] [level=${level} title=${title} summary=${summary}]";
  else
	write_log -f "${EMINFO_LOG}" "E0000000 convert output to mailbody file error:"\
		"[${mailbody}]";
  fi

  echo "${mailbody}"
  return "${rc}"
}

# Convert plugin output to postdata
# Called by Script bin/postlog
# Usage:        conv_output2postdata  "${content}"
# Example:	conv_output2postdata  "{level}:{type}:{title | summary | details: item1. ### item2. ### item3. ### }"
#
conv_output2postdata() {
  local strings=$*  name= level= type= body= other=
  name=$(get_global_name)
  level=$(read_output 1 "${strings}" | tr '[a-z]' '[A-Z]')
  type=$(read_output 2 "${strings}")
  body=$(read_output 3 "${strings}")
  [ "${type}" == "str" ] && body=$(echo -e "${body}" | sed -e 's/<[^<^>]*>//g; s/&nbsp;//g;')  ### trim html tag if type=str
  other="others";
  echo "${name}${SPLIT}${level}${SPLIT}${body}${SPLIT}${other}"
}

# Get timestamp of plugin last-run.
# Output:	never_run | invalid_lastrun | "timestamps of last run"
#
get_lastrun() {
  local plugin_name=$1  result=  headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_lastrun error: missing plugin name";
	return 1
  }
  if [ ! -s ${TMP_LASTRUN} ]; then
	echo -e "${headline}" > ${TMP_LASTRUN}
	result="never_run"
  else
  	result=$(awk '($1~/\<'${plugin_name}'\>/) {print $2;exit}' ${TMP_LASTRUN} 2>&-)
  	[ -z "${result}" ] && {
		result="never_run" 
	} || {
		[ ! -z "${result//[0-9]/}" ]  && result="invalid_lastrun"
	}
  fi
  echo "${result}"
}

# Get timestamp of plugin next-run.
# Output:	null | invalid_nextrun | "timestamps of next run"
#
get_nextrun() {
  local plugin_name=$1 result=  headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_nextrun error: missing plugin name";
	return 1
  }
  if [ ! -s ${TMP_NEXTRUN} ]; then
	echo -e "${headline}" > ${TMP_NEXTRUN}
	result="null"
  else
	result=$(awk '($1~/\<'${plugin_name}'\>/) {print $2;exit}' ${TMP_NEXTRUN} 2>&-)
	[ -z "${result}" ] && {
		result="null"
	} || {
		[ ! -z "${result//[0-9]/}" ]  && result="invalid_nextrun"
	}
  fi
  echo "${result}" 
}

# Update timestamp of plugin last-run and next-run
# Note: 	only called on plugin finished.
# LogFlag:	CRIT0000 | 00000000
#
update_lastrun_and_nextrun() {
  local plugin_name=$1  rc=  errinfo=
  local now=$(date +%s) 
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 update_lastrun_and_nextrun error: missing plugin name";
	return 1
  }

  if [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ]; then
	local logfile="${EMINFO_LOG}"
  else
	local logfile="${INNER_LOG}"                                                                                   
  fi

  touch ${TMP_LASTRUN} ${TMP_NEXTRUN}
  [ ! -s ${TMP_LASTRUN} ] && echo -e "${headline}" > ${TMP_LASTRUN}
  [ ! -s ${TMP_NEXTRUN} ] && echo -e "${headline}" > ${TMP_NEXTRUN}

  # Step 1: first update last-run
  # following sed command will lead to some repeat records.
  # sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}'/;tk;$s/$/\n'${plugin_name}' '${now}'/;:k'  ${TMP_LASTRUN}
  local l_time=$(awk '/^'${plugin_name}'\>/' ${TMP_LASTRUN} 2>&-)
  if [ -z "${l_time}" ]; then
	### only collect stderr output
	errinfo=$( sed -i '$s/$/\n'${plugin_name}' '${now}'/' ${TMP_LASTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new lastrun item as nower: ${now}]"\
			"error: [${errinfo}]";
	else
		write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new lastrun item as nower: ${now}]"\
			"success";
	fi
  else
	### only collect stderr output
	errinfo=$( sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}'/' ${TMP_LASTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update lastrun time as nower: ${now}]"\
			"error: [${errinfo}]";
	else
		write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update lastrun time as nower: ${now}]"\
			"success";
	fi
  fi

  # Step 2: then read last-run and update next-run
  local lastrun=$(get_lastrun ${plugin_name})
  local frequency=$(get_frequency ${plugin_name})
  local nextrun=$(( ${lastrun} + $(conv_time2sec "${frequency}") ))
  # following sed command will lead to some repeat records.
  # sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${nextrun}'/;tk;$s/$/\n'${plugin_name}' '${nextrun}'/;:k' ${TMP_NEXTRUN}
  local n_time=$( awk '/^'${plugin_name}'\>/' ${TMP_NEXTRUN} 2>&-)
  if [ -z "${n_time}" ]; then
	### only collect stderr output
        errinfo=$( sed -i '$s/$/\n'${plugin_name}' '${nextrun}'/' ${TMP_NEXTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new nextrun item as ${nextrun}]"\
			"error: [${errinfo}]";
	else
                write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new nextrun item as ${nextrun}]"\
			"success";
	fi
  else
	### only collect stderr output
        errinfo=$( sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${nextrun}'/' ${TMP_NEXTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update nextrun as ${nextrun}]"\
			"error: [${errinfo}]";
	else
                write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update nextrun as ${nextrun}]"\
			"success";
        fi
  fi

}


# Update status of plugin result.
# Note:         only called on plugin finished or output result.
#
update_status() {
  local plugin_name=${1//[ ]} rc= errinfo= ; shift
  local content=$*
  local now=$(date +%s)
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 update_status error: missing plugin name";
        return 1
  }

  if [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ]; then
	local logfile="${EMINFO_LOG}"
  else
	local logfile="${INNER_LOG}"                                                                                   
  fi

  
  touch ${TMP_STATUS}
  [ ! -s ${TMP_STATUS} ] && echo -e "${headline}" > ${TMP_STATUS}

  local l_record=$(awk '/^'${plugin_name}'\>/' ${TMP_STATUS} 2>&-)
  if [ -z "${l_record//[ ]}" ]; then
	echo "${plugin_name} ${now} ${content}" >> ${TMP_STATUS} 2>/dev/null
	rc=$?
	if [ "${rc}" != "0" ]; then
	       write_log -f "${logfile}" "E0000000 update_status on plugin:"\
			"[${plugin_name}] for [append newitem] error";
	else
	       write_log -f "${logfile}" "00000000 update_status on plugin:"\
			"[${plugin_name}] for [append newitem] success";
	fi
  else
	### following sed command can NOT deal with special chars. (if ${content} contains /)
	# sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}' '${content}'/' ${TMP_STATUS}
	errinfo=$( sed -i '/^'${plugin_name}'\>/d' ${TMP_STATUS} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
	       write_log -f "${logfile}" "E0000000 update_status on plugin:"\
			"[${plugin_name}] for [delete olditem error: ${errinfo}]";
	else
	       write_log -f "${logfile}" "00000000 update_status on plugin:"\
			"[${plugin_name}] for [delete olditem] success"
	       echo "${plugin_name} ${now} ${content}" >> ${TMP_STATUS} 2>/dev/null
	       rc=$?
	       if [ "${rc}" != "0" ]; then
			write_log -f "${logfile}" "E0000000 update_status on plugin:"\
				"[${plugin_name}] for [append newitem] error";
	       else
			write_log -f "${logfile}" "00000000 update_status on plugin:"\
				"[${plugin_name}] for [append newitem] success";
	       fi
	fi
  fi

  return "${rc}"
}


# Check accumulated return-err number overthan err-limit or not
# Output:	{0 =>no | 1 =>yes}  {now_err_num}  {err_num_limit}  
# Usage:        check_repeat_errcount  plugin_name
# Example:	check_repeat_errcount  check_sysload
#
check_repeat_errcount() {
  local plugin_name=$1 result=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 check_repeat_errcount error: missing plugin name";
        return 1
  }

  touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  local _repeat_errlimit=$( get_maxerr_times "${plugin_name}" )
  local repeat_errcount=$(awk '/^'${plugin_name}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-)
  [ -z "${repeat_errcount}" -o ! -z "${repeat_errcount//[0-9]}" ] && repeat_errcount=0  # set default whatever.

  [ "$(echo "${repeat_errcount}>=${_repeat_errlimit}" | bc 2>&-)" == "1" ] && {
	result=1    # reached  
  } || {
	result=0    # unreached
  }

  echo "${result}" "${repeat_errcount}" "${_repeat_errlimit}"
}

# Accumulated return-err number +1 
# Note: 	only called at plugin return err (non-zero)
# Usage:        add_repeat_errcount  plugin_name
# Example:	add_repeat_errcount  check_sysload
# Note:   null 	        =>   insert new and update to 1
# 	  not numberic  =>   update to 1
#         numberic	=>   update to +1
#
add_repeat_errcount() {
  local plugin_name=$1  rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount error: missing plugin name";
        return 1
  }

  touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  local repeat_errcount=$(awk '/^'${plugin_name}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-)
  if [ -z "${repeat_errcount}" ]; then		## null => update to 1 (add to last line)
        ### only collect stderr output
	errinfo=$( sed -i '$s/$/\n'${plugin_name}' 1/' ${TMP_REPEAT} 2>&1 1>/dev/null )
   	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount on plugin:"\
			"[${plugin_name}] for [empty, add new item as 1]"\
			"error: [${errinfo}]";
	else
		write_log -f "${EMINFO_LOG}" "00000000 add_repeat_errcount on plugin:"\
			"[${plugin_name}] for [empty, add new item as 1]"\
			"success";
	fi
  else
	if [ ! -z "${repeat_errcount//[0-9]}" ]; then    ## not null but invalid => update to 1
		### only collect stderr output
		errinfo=$( sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' 1/' ${TMP_REPEAT} 2>&1 1>/dev/null )
		rc=$?
		if [ "${rc}" != "0" ]; then
			write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [invalid => not numberic [${repeat_errcount}] and update as 1]"\
				"error: [${errinfo}]";
		else
			write_log -f "${EMINFO_LOG}" "00000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [invalid => not numberic [${repeat_errcount}] and update as 1]"\
				"success";
		fi
	else
  		local num=$(( ${repeat_errcount} + 1 ))  ## not null and numberic => update to +1
		### only collect stderr output
		errinfo=$( sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${num}'/' ${TMP_REPEAT} 2>&1 1>/dev/null )
		rc=$?
		if [ "${rc}" != "0" ]; then
			write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [valid => [${repeat_errcount}] and update as +1]"\
				"error: [${errinfo}]";
		else
			write_log -f "${EMINFO_LOG}" "00000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [valid => [${repeat_errcount}] and update as +1]"\
				"success";
		fi
	fi
  fi
}

# Reset accumulated return-err number to 0
# Note:		only called at plugin return ok (zero)
# Example:	zero_repeat_errcount  check_sysload
#
zero_repeat_errcount() {
  local plugin_name=$1  rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 zero_repeat_errcount error: missing plugin name";
        return 1
  }

  touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  # only collect stderr  output
  errinfo=$( sed -i '/^'${plugin_name}'\>/d' ${TMP_REPEAT} 2>&1 1>/dev/null)
  rc=$?
  if [ "${rc}" == "0" ]; then
	write_log -f "${EMINFO_LOG}" "00000000 zero_repeat_errcount on plugin:"\
		"[${plugin_name}] success.";
  else
	write_log -f "${EMINFO_LOG}" "E0000000 zero_repeat_errcount on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  fi

  return "${rc}"
}

# List enabled plugins include inners
#
list_enabled_plugin_section() {
  # list_plugin_section | while read plugin_name
  for plugin_name in `list_plugin_section`
  do
	[ "$(get_enable ${plugin_name})" == "yes" ] && echo "${plugin_name}"
  done

  for plugin_name in `list_inner_plugin_section`
  do
	echo "${plugin_name}"
  done
}

# List running plugins include inners
# 
list_running_plugin_section() {
  for plugin_name in `list_plugin_section` `list_inner_plugin_section`
  do
	lock_result=$(check_lock ${plugin_name})
	[ ! -z "${lock_result}" -a -z "${lock_result//[0-9]}" ] && echo "${plugin_name}"
  done
}

# Generate an empty temporary file for plugin if needed.
# Output:	path of temporary file
# Usage:	gen_tmpfile  plugin_name
# Example:	gen_tmpfile  check_sysload
#
gen_tmpfile() {
  local plugin_name=$1  rc=  errinfo=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 gen_tmpfile error: missing plugin name";
	return 1
  }

  [ ! -d "${TMP_DIR}/${plugin_name}" ] && mkdir -p ${TMP_DIR}/${plugin_name} 2>&-
  local filepath="${TMP_DIR}/${plugin_name}/${plugin_name}_$(mktemp -u XXXXXXXX)"
  # only collect stderr output.
  errinfo=$( touch "${filepath}" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" == "0" ]; then
  	echo "${filepath}"
	write_log -f "${EMINFO_LOG}" "00000000 gen_tmpfile success:"\
		"[${filepath}]";
  else
	write_log -f "${EMINFO_LOG}" "E0000000 gen_tmpfile error:"\
		"touch tmpfile [${filepath}]"\
		"return error: [${errinfo}]";
  fi

  return "${rc}"
}

# Time to run plugin or not ( nower timestamp > next-run timestamp or not)
# Usage:	time2run_ornot  plugin_name
# Output:	yes | no
#
time2run_ornot() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 time2run_ornot error: missing plugin name";
	return 1
  }
  local nextrun=$(get_nextrun ${plugin_name})
  local now=$(date +%s)
  [ "$(echo "${nextrun} <= ${now}"|bc)" == "1"  ] && result="yes" || result="no"
  echo "${result}"
}

# Generate run-lock on plugin  (atomic operation)
# Usage:        gen_lock  plugin_name
#
gen_lock() {
  local plugin_name=$1  rc=  errinfo=  logfile=  p_path=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 gen_lock error: missing plugin name";
  	return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
	p_path="${PLUGIN_DIR}/${plugin_name}"
	logfile="${EMINFO_LOG}"
  } || {
   	p_path="${INNER_DIR}/${plugin_name}"
	logfile="${INNER_LOG}"
  }
  # only collect stderr output.
  errinfo=$( ln -s "${p_path}" "${RUN_DIR}/${plugin_name}.lock" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 gen_lock on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 gen_lock on plugin:"\
		"[${plugin_name}] success.";
  fi

  return "${rc}"
}

# Unlock plugin
# Usage:        un_lock  plugin_name
#
un_lock() {
  local plugin_name=$1  rc=  errinfo=  logfile=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 un_lock error: missing plugin name";
        return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        logfile="${EMINFO_LOG}"
  } || {
        logfile="${INNER_LOG}"
  }
  # only collect stderr output.
  errinfo=$( unlink "${RUN_DIR}/${plugin_name}.lock" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 un_lock on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 un_lock on plugin:"\
		"[${plugin_name}] success";
  fi
  return "${rc}"
}

# Remove pidfile for plugin
# Usage:	del_fpid  plugin_name
#
del_fpid() {
  local plugin_name=$1  rc=  errinfo=  logfile=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 del_fpid error: missing plugin name";
        return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        logfile="${EMINFO_LOG}"
  } || {
        logfile="${INNER_LOG}"
  }
  # only collect stderr output.
  errinfo=$( rm -f "${RUN_DIR}/${plugin_name}.pid" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 del_fpid on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 del_fpid on plugin:"\
		"[${plugin_name}] success.";
  fi
  return "${rc}"
}

# Check run-lock status for plugin
# Output:	nolock | linkerror | start timestamp (plugin is running)
# Usage:        check_lock  plugin_name
# Example:	check_lock  check_sysload
#
check_lock() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 check_lock error: missing plugin name";
	return 1
  }
  # [ -e ${RUN_DIR}/${plugin_name}.lock ] && {   ###  never check broken link: never return linkerror
  if [ -L "${RUN_DIR}/${plugin_name}.lock" ]; then
	local f=$(readlink "${RUN_DIR}/${plugin_name}.lock" 2>&-)
	[ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        	local p_path="${PLUGIN_DIR}/${plugin_name}"
		local logfile="${EMINFO_LOG}"
	} || {
		local p_path="${INNER_DIR}/${plugin_name}"
		local logfile="${INNER_LOG}"
	}
	if [ "${f}" == "${p_path}" -a -f "${p_path}" ]; then
		result=$(stat -c %Y ${RUN_DIR}/${plugin_name}.lock 2>&-) 
		[ -z "${result}" -o ! -z "${result//[0-9]}" ] && {
			write_log -f "${logfile}" "E0000000 check_lock on [${plugin_name}] error: "\
				"runlock timestamp is not numberic: [${result}], "\
				"return linkerror";
			result="linkerror"
		}
	else
		write_log -f "${logfile}" "E0000000 check_lock on [${plugin_name}] error: "\
				"runlock link->target is mistake or target not exist: "\
				"[${f}] ==> [${p_path}], "\
				"return linkerror";
		result="linkerror"
	fi
  else
	result="nolock"
  fi

  echo "${result}"
}

# Remove error lock and dead pid for plugin
# Clear conditions:
# 1. lock exists, but run-lock link error   ==>  remove lock
# 2. lock exists, but pid file not exists   ==>  remove lock
# 3. lock exists, pid file exist, but according to the pid file, no process running ==> remove lock,remove pidfile
# 4. pid file exists, but according to the pid file, no process running ==> remove pidfile
# Note:		No arguments will clear all plugins.
# Usage:	clear_dead_lock_pid  [ plugin_name ]
# Example1:	clear_dead_lock_pid  check_sysload
# Example2:	clear_dead_lock_pid
# LogFlag:	D0000000
#
clear_dead_lock_pid() {
  local plugin_name=$1

  clear_single_dead_lock_pid() {
	local _p=$1  _rc=
	[ -z "${_p}" ] && {
		write_log -f "${EMINFO_LOG}" "E0000000 clear_single_dead_lock_pid error: missing plugin name";
		return 1
	}
  	if [ -z "$( echo "${_p}" | grep -E -o "^eminfo_" )" ]; then
        	local logfile="${EMINFO_LOG}"
	else
        	local logfile="${INNER_LOG}"
  	fi

	[ -L "${RUN_DIR}/${_p}.lock" ] && {
		if [ "$(check_lock  "${_p}")" == "linkerror" ]; then   ### condition: 1
			write_log -f ${logfile} "D0000000 EMINFO remove linkerror lock for"\
				"[${_p}]: link error";
			un_lock "${_p}"
		fi
		if [ ! -f "${RUN_DIR}/${_p}.pid" ]; then  ### condition: 2
			write_log -f ${logfile} "D0000000 EMINFO remove dead lock for"\
				"[${_p}]: pid not exists";
			un_lock "${_p}"        
		else
			check_ps_by_pid_file "${RUN_DIR}/${_p}.pid" 1>/dev/null 2>&1
			_rc=$?
			if [ "$_rc" != "0" ]; then  ### condition: 3
				write_log -f ${logfile} "D0000000 EMINFO remove dead lock and pid for"\
					"[${_p}]: pid exists but process not running";
				un_lock "${_p}"  
				del_fpid "${_p}"
			fi
		fi
	}
	if [ -s "${RUN_DIR}/${_p}.pid" ]; then
		check_ps_by_pid_file "${RUN_DIR}/${_p}.pid" 1>/dev/null 2>&1
		_rc=$?
		if [ "$_rc" != "0" ]; then  ### condition: 4
			write_log -f ${logfile} "D0000000 EMINFO remove dead pid for [${_p}]";
			del_fpid "${_p}"
		fi
	fi
  }

  if [ -z "${plugin_name}" ]; then
	# list_plugin_section | while read p   
	for p in `list_plugin_section`
	do
		clear_single_dead_lock_pid "${p}"
	done 
	for q in `list_inner_plugin_section`
	do
		clear_single_dead_lock_pid "${q}"
	done
  else
	clear_single_dead_lock_pid "${plugin_name}"
  fi
}

# According to input pid file to stop process.
# Steps:
# 1. read first line from pid file as pids.
#  1.1. for each pid, if directory /proc/${pid}/ exists, search all of its son-pids
#  1.2. send signal TERM to all son pids
#  1.3. read /proc/${pid}/cmdline as variable cmdline1
#  1.4. send signal TERM to ${pid}, sleep 1 seconds in case the process trap signal TERM
#  1.5. if directory /proc/${pid}/ still exists, read /proc/${pid}/cmdline as variable cmdline2
#  1.6. if cmdline1=cmdline2, send signal KILL to ${pid}, no more than 3 times.
# 2. remove pid file
# Usage:	stopps_by_pidfile   /path/to/pid/file
# Example:	stopps_by_pidfile   /var/run/crond.pid
# LogFlag: 	STP00000
#
stopps_by_pidfile() {
  local fpid=$1
  [ -z "${fpid}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 stopps_by_pidfile error:"\
		"missing arguments, fpid=[${fpid}]";
  	return 1
  }

  if [ -f "${fpid}" ]; then
	read line < ${fpid}    ### step: 1
	write_log -f "${EMINFO_LOG}" "STP00000 EMINFO read pids from pidfile:"\
		"[${fpid}] result: [${line}]";

	for x in `echo ${line}`;do
		[ -z "${x//[0-9]/}" -a -d "/proc/${x}" ] && {
			local children_pids=$(get_children_pids_by_pid ${x})    ### step: 1.1
			write_log -f "${EMINFO_LOG}" "STP00000 EMINFO get_children_pids for pid:"\
				"[${x}] result:[${children_pids}]";

			for cpid in `echo ${children_pids}`    ### step: 1.2
			do
				local cmdline=$(ps -p "${cpid}" -o cmd= 2>&-)
				write_log -f "${EMINFO_LOG}" "STP00000 EMINFO terminating child pid:"\
					"[${cpid}] => [${cmdline}] SIG:TERM";
				kill -15  "${cpid}" 1>&- 2>&-
			done

			local cmdline1=$(cat /proc/${x}/cmdline 2>&-)    ### step: 1.3

			local cmdline=$(ps -p "${x}" -o cmd= 2>&-)
			write_log -f "${EMINFO_LOG}" "STP00000 EMINFO terminating father pid:"\
				"[${x}] => [${cmdline}] SIG:TERM ";
			kill -15 "${x}" 1>&- 2>&-	 ### step: 1.4
			sleep 1

			if [ -d "/proc/${x}" ]; then
				local cmdline2=$(cat /proc/${x}/cmdline 2>&-)    ### step: 1.5
				local kn=1  kmax=3
				until [ "${cmdline1}" != "${cmdline2}" ]     ### step: 1.6
				do
					write_log -f "${EMINFO_LOG}" "STP00000 EMINFO father pid:"\
						"[${x}] => [${cmdline2}] still running, kill it by SIG:KILL, times:[${kn}]";
					kill -9 ${x} 1>&- 2>&-
					sleep 0.1
					local cmdline2=$(cat /proc/${x}/cmdline 2>&-)
					((kn++))
					### kill the process no more than ${kmax} times.
					[ "$( echo "${kn}>${kmax}" | bc 2>&- )" == "1" ] && break
				done
			else
				write_log -f "${EMINFO_LOG}" "STP00000 EMINFO terminate father pid:"\
					"[${x}] => [${cmdline}] SIG:TERM success";
			fi
		}
	done

	local errinfo=  rc=
  	errinfo=$( rm -f "${fpid}" 2>&1 1>/dev/null )    ### step: 2
	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${EMINFO_LOG}" "STP00000 EMINFO remove pidfile:"\
			"[${fpid}] error: [${errinfo}]";
		return 2
	else
		write_log -f "${EMINFO_LOG}" "STP00000 EMINFO remove pidfile:"\
			"[${fpid}] success";
		return 0
	fi
  else
	write_log -f "${EMINFO_LOG}" "E0000000 stopps_by_pidfile error:"\
		"input pidfile not exists: [${fpid}]";
	return 3
  fi
}

# Stop plugin	( kill process / remove pid / unlock )
# Usage:	stop_single_plugin   plugin_name
# LogFlag: 	STP00000 
#
stop_single_plugin() {
  local plugin_name=$1  
  local pidfile="${RUN_DIR}/${plugin_name}.pid"
  if [ -z "${plugin_name}" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 stop_single_plugin error: missing plugin name";
	return 1
  else
	write_log -f "${EMINFO_LOG}" "STP00000 EMINFO stop plugin"\
		"[${plugin_name}]: 1 => stop process on pidfile: [${pidfile}]";
	# local plugin_pid=$(cat "${pidfile}" 2>&-)
	# local plugin_cmd=$(cat /proc/${plugin_pid}/cmdline 2>&-)
	# if [ "$(sub_str "${plugin_cmd}" "${plugin_name}")" == "yes" ]; then
		# write_log -f "${EMINFO_LOG}" STP00000 EMINFO stop plugin "[${plugin_name}]: 1.1 => pid=[${plugin_pid}],command=[${plugin_cmd}]. check fake OK"
  		# stopps_by_pidfile "${pidfile}"
	# else
		# write_log -f "${EMINFO_LOG}" STP00000 EMINFO stop plugin "[${plugin_name}]: 1.1 => pid=[${plugin_pid}],command=[${plugin_cmd}] Error: running process fake => END"
		# return 1
	# fi
  	stopps_by_pidfile "${pidfile}"
	write_log -f "${EMINFO_LOG}" "STP00000 EMINFO stop plugin"\
		"[${plugin_name}]: 2 => remove lockfile";
  	un_lock "${plugin_name}"
  fi
}

# Check plugin has been running timeout or not  (must be running,otherwise return error directly)
# Output:	yes | no | error (maybe not ruuning)
# Usage:	timeout_ornot  plugin_name
# Example:	timeout_ornot  check_sysload
#
timeout_ornot() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 timeout_ornot error: missing plugin name";
	return 1
  }
  local exec_tmout=$(conv_time2sec "$(get_exec_tmout ${plugin_name})")
  local starttime=$(check_lock ${plugin_name})
  if [ -z "${starttime}" -o ! -z "${starttime//[0-9]/}" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 timeout_ornot error:"\
		"starttime [${starttime}] not numberic on plugin "\
		"[${plugin_name}]: maybe not running.";
	result="error"
  else
	local durationtime=$(echo " "$(date +%s)" - "${starttime}" " | bc 2>&-) 
  	[ "$(echo "${durationtime} >= ${exec_tmout}"|bc)" == "1" ] && result="yes" || result="no"
  fi
  echo "${result}"
}

# Add run-lock on plugin while pid file not exist
# Note:		called to add run-lock at next scan period begins, previous plugin has already finished. 
# 		No need to check previous plugin running timeout or not
# Output:	0 1   ==>  Succ | Fail
# Usage:        add_runlock_on_pid_notexist      plugin_name
# LogFlag: 	P0000000
#
add_runlock_on_pid_notexist(){
  local plugin_name=$1 _rc=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 add_runlock_on_pid_notexist error: missing plugin name";
        return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        local logfile="${EMINFO_LOG}"
  } || {
        local logfile="${INNER_LOG}"
  }

  gen_lock "${plugin_name}"
  _rc=$?
  if [ "${_rc}" != "0" ]; then
	write_log -f ${logfile} "P0000000 EMINFO add runlock on"\
		"[${plugin_name}]: without pidfile but add runlock: failed. EXIT";
	return 1
  else
	write_log -f ${logfile} "P0000000 EMINFO add runlock on"\
		"[${plugin_name}]: without pidfile and add runlock: succeed. OK";
	return 0
  fi
}

# Check run-lock on plugin while pid file exists
# Note:		called to check run-lock at next scan period begins, previous plugin is still running.
# Output: 	0 1 2 3 4 5
# Steps:
#   0: running, but timeout  ==>  stop plugin  ==>  process_plugin_timeout  ==>  skip 
#   1: running, and NOT timeout  ==>  skip
#   2: linkerror  ==>  remove dead run-lock  ==>  skip
#   3: nolock  ==>  add run-lock  ==>  failed  ==>  skip
#   4: nolock  ==>  add run-lock  ==>  succ    ==>  process_plugin
#   5: unknown  ==>  skip
# Usage:	check_runlock_on_pid_exist  plugin_name
# Example:	check_runlock_on_pid_exist  check_sysload   
# LogFlag: 	L0000000
#
check_runlock_on_pid_exist() {
  local plugin_name=$1  r_c=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 check_runlock_on_pid_exist error: missing plugin name";
        return 1
  }

  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
	local logfile="${EMINFO_LOG}"
  } || {
	local logfile="${INNER_LOG}"
  }

  local lockinfo=$(check_lock "${plugin_name}")
  [ -z "${lockinfo//[0-9]/}" ] && {	    ###   is running
	#### this will lead to plenty of records in {EMINFO_LOG}  while plugin running for a long time.
	## write_log -f ${logfile} L0000000 EMINFO plugin "[${plugin_name}]" already running. CHECK EXEC_TMOUT
	if [ "$(timeout_ornot "${plugin_name}")" == "yes" ]; then   ### condition: 0
		write_log -f ${logfile} "L0000000 EMINFO plugin"\
			"[${plugin_name}] running but timeout. STOP IT";
		process_plugin_timeout "${plugin_name}"
		return 0
	else    
		#### this will lead to plenty of records in {EMINFO_LOG}  while plugin running for a long time.
		## write_log -f ${logfile} L0000000 EMINFO plugin "[${plugin_name}]" running and not_timeout. SKIP
		return 1	### condition: 1
	fi
  }

  [ "${lockinfo}" == "linkerror" ] && {
	un_lock "${plugin_name}"
	write_log -f ${logfile} "L0000000 EMINFO plugin"\
		"[${plugin_name}] running but linkerror. UNLOCK IT";
	return 2      ### condition: 2
  }

  [ "${lockinfo}" == "nolock" ] && {    ### not running
	gen_lock "${plugin_name}"
        r_c=$?
	if [ "${r_c}" != "0" ]; then
		write_log -f ${logfile} "L0000000 EMINFO add runlock on"\
			"[${plugin_name}]: without runlock but add runlock failed. EXIT";
		return 3      ### condition: 3
	else		
		write_log -f ${logfile} "L0000000 EMINFO add runlock on"\
			"[${plugin_name}]: without runlock and add runlock succeed. OK";
		return 4      ### condition: 4
	fi
  }

  write_log -f ${logfile} "L0000000 EMINFO plugin"\
	"[${plugin_name}] something unknown occure. EXIT";
  return 5 	### condition: 5
}

# List plugin status and scheduling information
#   		include: enable status starttime durationtime lastruntime frequency nextruntime repeaterrnum
# Usage:	list_plugin_status  [ plugin_name1 plugin_name2 plugin_name3 ... ]    
# Example1:	list_plugin_status  check_sysload  check_cpu_usage
# Example2:	list_plugin_status  all
#
list_plugin_status() {
  local plugin_name="$*"
  local headline="Plugin Enable Running StartOn Duration LastRun Frequency NextRun RepeatErr"
  list_single_status() {
	local _p=$1 enable= running= starttime= durationtime= lastruntime= frequency= nextruntime= repeaterrnum=
	local lastruntime=$(get_lastrun $_p) 
    	local frequency=$(get_frequency $_p)
	local nextruntime=$(get_nextrun $_p)
	local repeaterrnum=$(awk '/^'${_p}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-) 
	[ -z "${repeaterrnum}" -o ! -z "${repeaterrnum//[0-9]}" ] && repeaterrnum=0

	[ ! -z "$( echo "${_p}" | grep -E -o "^eminfo_" )" ] && {
		enable="yes"
	} || {
		enable=$(get_enable "${_p}")
        }

	if [ -z "${lastruntime//[0-9]/}" ]; then
		lastruntime=$(date -d "1970-01-01 UTC ${lastruntime} seconds" +%F_%T)
	else
		[ "${lastruntime}" == "never_run" ] && {
			lastruntime="Never_Run"
		} || {
			[ "${lastruntime}" == "invalid_lastrun" ] && {
				lastruntime="Internal_Error"
			} || {
				lastruntime="Unknown"
			}
		}
	fi

	if [ -z "${nextruntime//[0-9]/}" ]; then
		nextruntime=$(date -d "1970-01-01 UTC ${nextruntime} seconds" +%F_%T)
	else
		[ "${nextruntime}" == "null" ] && {
			nextruntime="NULL"
		} || {
			[ "${nextruntime}" == "invalid_nextrun" ] && {
				nextruntime="Internal_Error"
			} || {
				nextruntime="Unknown"
			}
		}
	fi

 	[ "${enable}" == "yes" ] && {
		enable="Yes"
	} || {
		enable="No" 
		nextruntime="-"
	}

	local lockinfo=$(check_lock $_p)
 	if [ -z "${lockinfo//[0-9]/}" ]; then
		running="Yes"
		starttime=$(date -d "1970-01-01 UTC ${lockinfo} seconds" +%F_%T)
		durationtime="$( echo "$(date +%s) - ${lockinfo}" | bc 2>&- )s"
	else
		running="No"
		starttime="-"
		durationtime="-"
	fi

	echo "$_p ${enable} ${running} ${starttime} ${durationtime} ${lastruntime} ${frequency} ${nextruntime} ${repeaterrnum}"
	# echo "p=$_p e=${enable} r=${running} s=${starttime} d=${durationtime} l=${lastruntime} f=${frequency} n=${nextruntime} r=${repeaterrnum}"
	
	
  }

  if [ "${plugin_name}" == "all" ]; then
		{  echo "${headline}"
  		# list_plugin_section | while read p 
		for p in `list_plugin_section`
		do
			[ ! -z "${p}" ] &&  list_single_status "${p}"
		done 
		# echo "===========  Eminfo Inner Plugins   ============"
		for q in `list_inner_plugin_section`
		do
			[ ! -z "${q}" ] && list_single_status "${q}"
		done
		} | column -t 
  else
		{ echo "${headline}" 
		for o in `echo "${plugin_name}"`
		do
			list_single_status "${o}" 
		done
		} | column -t
  fi
}

# Enable Plugin (update config file to set enable = yes)
# LogFlag	ENAB0000
#
enable_plugin(){
  local plugin_name=$1  rc=
  write_log -f "${EMINFO_LOG}" "ENAB0000 enable_plugin trying to enable plugin [${plugin_name}]";
  update_eminfo_config "${plugin_name}" "enable" "yes"
  rc=$?
  return "${rc}"
}

# Disable Plugin (update config file to set enable = no)
# LogFlag	DSAB0000
#
disable_plugin() {
  local plugin_name=$1  rc=
  write_log -f "${EMINFO_LOG}" "DSAB0000 disable_plugin trying to disable plugin [${plugin_name}]";
  update_eminfo_config "${plugin_name}" "enable" "no"
  rc=$?
  return "${rc}"
}

# Reset scheduling information and repeat err-num of plugin
# Note:		No arguments will reset all plugins
# Usage:	init_plugin  [plugin_name]
# Example1:	init_plugin  check_sysload
# Example2:	init_plugin 
# LogFlag:	INIT0000
# 
init_plugin() {
  local plugin_name=$1
  if [ -z "${plugin_name}" ]; then
	write_log -f "${EMINFO_LOG}" "INIT0000 resetting all plugins ...";
	: > ${TMP_LASTRUN} >/dev/null 2>&1
  	: > ${TMP_NEXTRUN} >/dev/null 2>&1
  	: > ${TMP_REPEAT}  >/dev/null 2>&1
  else
	write_log -f "${EMINFO_LOG}" "INIT0000 resetting plugin: [${plugin_name}] ..."
 	sed -i '/^'${plugin_name}'\>/d' ${TMP_LASTRUN} > /dev/null 2>&1
 	sed -i '/^'${plugin_name}'\>/d' ${TMP_NEXTRUN} > /dev/null 2>&1
 	sed -i '/^'${plugin_name}'\>/d' ${TMP_REPEAT}  > /dev/null 2>&1
  fi
  return $?
}

# List base-config-name ==> config-value of plugin
# Note:		No arguments will list all plugins
# Note:		Extra (user-defination) config-name will not be displayed.
# Usage:  view_base_config 	plugin_name
# 
view_base_config() {
  local plugin_name=$1
  [ -z "${plugin_name}" ] && {
	echo_red "view_base_config error: please specify plugin name."; echo
	return 1
  }
  echo_green "[${plugin_name}]: basic configuration" ; echo
  { 
	echo "config_name ==> value ==> is_default"
  	for cname in ${ARRAY_BASE_CONFIG[@]} 
  	do
        	cvalue=$(read_eminfo_config ${plugin_name} ${cname})
        	if [ -z "${cvalue}" ]; then
                	cvalue="$(read_eminfo_config plugin_default ${cname}) ==> Yes"
		else
			cvalue="${cvalue} ==> No"
        	fi
        	echo -e  "${cname} ==> ${cvalue} "
  	done
  } | column -t -s "==>"
}

# List user-defined-config-name ==> config-value of plugin
# Note:         No arguments will list all plugins
# Note:         Basic config-name will not be displayed.
# Usage:  view_extra_config      plugin_name
# 
view_extra_config() {
  local plugin_name=$1
  [ -z "${plugin_name}" ] && {
	echo_red "view_extra_config error: please specify plugin_name."; echo
 	return 1
  }
  echo_green "[${plugin_name}]: extra configuration" ; echo
  {
	search_tag=0  headline="config_name(user-def) ==> value"
  	for cname in `list_section_keys "${plugin_name}"`
  	do
		[ "$(echo -e "${ARRAY_BASE_CONFIG[@]}"  | grep -E -o -w "${cname}")" == "" ] && {  ### 2. user-def config
			cvalue=$(read_eminfo_config ${plugin_name} ${cname})
			[ "${search_tag}" == "0" ] && echo -e "${headline}"
			echo -e "${cname} ==> ${cvalue}"
			search_tag=1
		}
  	done
  } | column -t -s "==>"
}

# Process plugin 
# Note:		core function, each registered and enabled plugin will be handed over to this function.
# Usage:        process_plugin   plugin_name
# LogFlag:	random 8 character
#
process_plugin() {

  local plugin_name=$1  output=  plain_output=

  # Step 1: set jid / set debug flag / set logfile
  local jid=$(mktemp -u XXXXXXXX)      ### set random/unique jid
  export _LOG="${EMINFO_LOG}"          ### set logfile 
  local debug=$(get_debug "${plugin_name}")   ### set debug flag
  [ "${debug}" == "yes" ] && export _DEBUG="1" || export _DEBUG="0"

  # Step 2: check current overloaded or not,  yes ==> process_sysoverload ==> return
  SYSLOAD_UPLIMIT=$( read_eminfo_config global sysload_uplimit )
  [ -z "${SYSLOAD_UPLIMIT}" -o ! -z "${SYSLOAD_UPLIMIT//[0-9]}" ] && SYSLOAD_UPLIMIT=30
  local sysload=$( cut -d" " -f1 /proc/loadavg 2>&- )
  if [ "$(echo  "${sysload} > $SYSLOAD_UPLIMIT" | bc 2>&-)" == "1" ]; then	### plugin finished.
	write_log -f "${EMINFO_LOG}" "${jid} ${plugin_name} system overloaded:"\
		"[${sysload}] uplimit: [${SYSLOAD_UPLIMIT}] EXIT";
	process_sysoverload "${plugin_name}" "${sysload}" "${SYSLOAD_UPLIMIT}"
	update_lastrun_and_nextrun "${plugin_name}"
	del_fpid "${plugin_name}"
	un_lock "${plugin_name}"
	write_log ${jid} ${plugin_name}\
		"update lastrun time / release LOG / release runlock done. FINISHED.";
	unset _LOG
	return 1
  else
	write_log ${jid} ${plugin_name} "system load normal: [${sysload}] CONTINUE";
  fi

  # Step 3: check if input plugin-name registered in config file or not
  write_log ${jid} ${plugin_name} "START";
  if [ -z "${plugin_name}" ]; then   ### check null
	write_log ${jid} "plugin_name empty. please specify plugin_name. EXIT";
	update_status "${plugin_name}" "EXIT on Null Name"
	update_lastrun_and_nextrun "${plugin_name}"
	del_fpid "${plugin_name}"
	un_lock "${plugin_name}"
	unset _LOG
	return 1
  else
  	if [ "$(read_eminfo_section "${plugin_name}" )" != "${plugin_name}" ]; then   ### check registered
		write_log ${jid} ${plugin_name} "not registered in config file. EXIT";
		update_status "${plugin_name}" "EXIT on Not Registered";
		update_lastrun_and_nextrun "${plugin_name}"
		del_fpid "${plugin_name}"
		un_lock "${plugin_name}"
		unset _LOG
		return 2
	else
		write_log ${jid} ${plugin_name} "registered in config file. CONTINUE";
	fi
  fi

  # Step 4: check if input plugin-name enabled in config file or not
  local status=$(get_enable "${plugin_name}")
  if [ "${status}" != "yes" ]; then	### skip disabled plugins
	write_log ${jid} ${plugin_name} "not enabled."\
		"status=[${status}] EXIT";
	update_status "${plugin_name}" "EXIT on Not Enabled"
	update_lastrun_and_nextrun "${plugin_name}"
	del_fpid "${plugin_name}"
	un_lock "${plugin_name}"
	unset _LOG
	return 0
  else
	write_log ${jid} ${plugin_name} "enabled. status=[${status}] CONTINUE";
  fi

  # Step 5: check if plugin file exists under PLUGIN_DIR or not
  if [ ! -f "${PLUGIN_DIR}/${plugin_name}" ]; then
	write_log ${jid} ${plugin_name} "plugin file:"\
		"[${PLUGIN_DIR}/${plugin_name}] not exist. EXIT";
	update_status "${plugin_name}" "EXIT on Plugin File Not Found"
	update_lastrun_and_nextrun "${plugin_name}"
	del_fpid "${plugin_name}"
	un_lock "${plugin_name}"
	unset _LOG
	return 3
  else
	write_log ${jid} ${plugin_name} "plugin file:"\
		"[${PLUGIN_DIR}/${plugin_name}] exist ==> exec. CONTINUE";
  fi

  # Step 6: exec plugin / obtain returned code / obtain returned stuff
  [ ! -x "${PLUGIN_DIR}/${plugin_name}" ] && chmod a+x "${PLUGIN_DIR}/${plugin_name}"
  ### local is wrong: won't get return code, return code always be 0.
  #@# local output=$( eval "${PLUGIN_DIR}/${plugin_name}" 2>&1 )  
  output=$( eval "${PLUGIN_DIR}/${plugin_name}" 2>&1 )
  local rc=$?
  # trim html tag in plugin output. convert html output into plain.
  plain_output=$( ${PLUTIL} format_pstr_output_toplain "${output}" ) 
  write_log -f ${EMINFO_LOG} ${jid} ${plugin_name} "execution completed."\
	"return code: [${rc}]  return string: [${plain_output}]. CONTINUE";
  update_status "${plugin_name}" "${output}"


  # Step 7: special steps.   
  # while plugin return status = 0(OK) or 4(NOOP)
  # return status: 0:OK  
  if [ "${rc}" == "0" ]; then    
	write_log ${jid} ${plugin_name}\
		"return status: [OK]. try to zero repeat errcount. CONTINUE";
	## reset accumulated return-err number => 0
	zero_repeat_errcount "${plugin_name}"
  # return status: 4:NOOP
  elif [ "${rc}" == "4" ]; then  ### plugin finished. 
	write_log ${jid} ${plugin_name}\
		"return status: [NOOP]. Noting to do.  EXIT";
	# update_status "${plugin_name}" "EXIT on Return NOOP"
	update_lastrun_and_nextrun "${plugin_name}"
	del_fpid "${plugin_name}"
	un_lock "${plugin_name}"
	write_log ${jid} ${plugin_name}\
		"update lastrun time / release LOG / release runlock done. FINISHED.";
	unset _LOG
	return 0
  # return status: (1/2/3) == (! 0/4)
  else  
	write_log ${jid} ${plugin_name}\
		"return code: [${rc}]. try to +1 on repeat errcount. CONTINUE";
	### accumulated error number +1
  	add_repeat_errcount "${plugin_name}"
  	local array_repeat_err_stuff=()
  	array_repeat_err_stuff=( $(check_repeat_errcount ${plugin_name}) )
  	local _yes_ornot=${array_repeat_err_stuff[0]} 
	local _now_errcount=${array_repeat_err_stuff[1]} 
	local _errcount_uplimit=${array_repeat_err_stuff[2]}
  	if [ "${_yes_ornot}" == "1" ]; then  # plugin continue
		write_log ${jid} ${plugin_name} "reached maximize errtimes:"\
			"[(${_now_errcount}) >= (${_errcount_uplimit})] CONTINUE";
  	else  # plugin finished
		write_log ${jid} ${plugin_name} "have-not-yet reached maximize errtimes:"\
			"[(${_now_errcount}) < (${_errcount_uplimit})] EXIT";
		# update_status "${plugin_name}" "EXIT on Not Reached MaxErr Limit"
        	update_lastrun_and_nextrun "${plugin_name}"
        	del_fpid "${plugin_name}"
        	un_lock "${plugin_name}"
        	write_log ${jid} ${plugin_name}\
			"update lastrun time / release LOG / release runlock done. FINISHED.";
        	unset _LOG
        	return 0
  	fi
  fi

  # Step 8: check action: take_snapshot_type
  local t_snap=$(take_action_ornot "${plugin_name}" take_snapshot_type ${rc})
  if [ "${t_snap}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "take snapshot disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "take snapshot enabled. CONTINUE";
	${TAKESNAP_SH} -f "${plugin_name}" -s "${jid}" 1>/dev/null 2>&1
	write_log ${jid} ${plugin_name} "take snapshot finished."\
		"detailis in ${TAKESNAP_LOG##*/}. CONTINUE";
  fi
	
  # Step 9: check action: mail_notify_type
  local m_alert=$(take_action_ornot "${plugin_name}" mail_notify_type ${rc})
  if [ "${m_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "mail notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "mail notify enabled. CONTINUE";
	${SENDMAIL} -f "${plugin_name}" -s "${jid}" -i "${output}"
	write_log ${jid} ${plugin_name} "mail notify finished."\
		"details in ${SENDMAIL_LOG##*/}. CONTINUE";
  fi

  # Step 10: check action: post_notify_type
  local p_alert=$(take_action_ornot "${plugin_name}" post_notify_type ${rc})
  if [ "${p_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "post notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "post notify enabled. CONTINUE";
	${POSTLOG_SH} -f "${plugin_name}" -s "${jid}" -i "${output}" # eval  will return syntax error. why ?
	write_log ${jid} ${plugin_name} "post notify finished."\
		"details in ${POSTLOG_LOG##*/}. CONTINUE";
  fi

  # Step 11: check action: auto_handle
  local a_hand=$(take_action_ornot "${plugin_name}" auto_handle_type ${rc})
  if [ "${a_hand}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "auto handle disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "auto handle enabled. CONTINUE";
	local handler=$(read_eminfo_config "${plugin_name}" auto_handler)
	[ -z "${handler}" ] && handler=$(read_eminfo_config plugin_default auto_handler)
	if [ -f "${HANDLER_DIR}/${handler}" -a -s "${HANDLER_DIR}/${handler}" ]; then
		write_log ${jid} ${plugin_name} "auto handler:"\
			"[${HANDLER_DIR}/${handler}] exists. CONTINUE";
 		[ ! -x "${HANDLER_DIR}/${handler}" ] && chmod a+x "${HANDLER_DIR}/${handler}" 2>&-
		local hd_output=
		hd_output=$( eval "${HANDLER_DIR}/${handler}" 2>&1 )
		local hd_rc=$?
		write_log ${jid} ${plugin_name} "auto handler execution completed."\
			"return code:[${hd_rc}] return string: [${hd_output}] CONTINUE";
  	else
		write_log ${jid} ${plugin_name} "auto handler:"\
			"[${HANDLER_DIR}/${handler}] not exist or empty. SKIP";
	fi
  fi

  # Step 12: plugin finished
  update_lastrun_and_nextrun "${plugin_name}"
  del_fpid "${plugin_name}"
  un_lock "${plugin_name}"
  write_log ${jid} ${plugin_name}\
	"update lastrun time / release LOG / release runlock done. FINISHED";
  unset _LOG
  return 0
}



# Process inner plugin, in fact simplified version of process_plugin
# Usage:	process_inner_plugin    plugin_name 
#
process_inner_plugin() {
  local plugin_name=$1  output=

  # Step 1: set random/unique jid
  local jid=$(mktemp -u XXXXXXXX)    

  # Step 2: check plugin script 
  write_log -f ${INNER_LOG} ${jid} ${plugin_name} "START"
  if [ ! -f "${INNER_DIR}/${plugin_name}" ]; then
        write_log -f ${INNER_LOG} ${jid} ${plugin_name} "plugin file:"\
		"[${INNER_DIR}/${plugin_name}] not exist. EXIT";
        del_fpid "${plugin_name}"
        un_lock "${plugin_name}"
        return 3
  else
        write_log -f ${INNER_LOG} ${jid} ${plugin_name} "plugin file:"\
		"[${INNER_DIR}/${plugin_name}] exist ==> exec. CONTINUE";
  fi

  # Step 3: execute plugin / get return stuff
  [ ! -x "${INNER_DIR}/${plugin_name}" ] && chmod a+x "${INNER_DIR}/${plugin_name}"
  output=$( eval "${INNER_DIR}/${plugin_name}" 2>&1 )
  write_log -f ${INNER_LOG} ${jid} ${plugin_name} "execution completed."\
	"return: [${output}]";

 # Step 4: plugin finished
 update_status "${plugin_name}" "${output}"
 update_lastrun_and_nextrun "${plugin_name}"
 del_fpid "${plugin_name}"
 un_lock "${plugin_name}"
 write_log -f ${INNER_LOG} ${jid} ${plugin_name} "execution DONE."

}

# Process plugin running timeout
# Usage:    	process_plugin_timeout   plugin_name
# LogFlag: 	TMT00000
# 
process_plugin_timeout() {
  local plugin_name=$1
  local output="{tmout}:{str}:{ Plugin Execution TimeOut"\
	"| $(html_red "${plugin_name}") execution timeout, has been terminated. }";

  # Step 0: update status
  update_status "${plugin_name}" "Cancle on Plugin TimeOut"

  # Step 1: stop timeout plugin 
  stop_single_plugin "${plugin_name}"
  # return here while inner plugin
  [ "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" != "" ] && return 0

  # Step 2: take snapshot
  local t_snap=$(take_action_ornot "${plugin_name}" take_snapshot_type "tmout")
  if [ "${t_snap}" != "yes" ]; then
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} take snapshot disabled. SKIP";
  else
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} take snapshot enabled. CONTINUE";
        ${TAKESNAP_SH} -f "${plugin_name}" -s "tmout" 1>/dev/null 2>&1
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} take snapshot finished."\
		"detailis in ${TAKESNAP_LOG##*/}. CONTINUE";
  fi

  # Step 3: send timeout notify mail
  local m_alert=$(take_action_ornot "${plugin_name}" mail_notify_type "tmout")
  if [ "${m_alert}" != "yes" ]; then
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} mail notify disabled. SKIP";
  else
	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} mail notify enabled. CONTINUE";
	${SENDMAIL} -f "${plugin_name}" -s "tmout" -i "${output}"
	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} send timeout mail:"\
		"finished. details in ${SENDMAIL_LOG##*/}. CONTINUE";
  fi

  # Step 4: post timeout information
  local p_alert=$(take_action_ornot "${plugin_name}" post_notify_type "tmout")
  if [ "${p_alert}" != "yes" ]; then
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} post notify disabled. SKIP";
  else
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} post notify enabled. CONTINUE";
        ${POSTLOG_SH} -f "${plugin_name}" -s "tmout" -i "${output}"  # eval will return syntax error. why?
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} post alert finished."\
		"details in ${POSTLOG_LOG##*/}. CONTINUE";
  fi

  # Step 5: auto handler while timeout
  local a_hand=$(take_action_ornot "${plugin_name}" auto_handle_type "tmout")
  if [ "${a_hand}" != "yes" ]; then
 	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handle disabled. SKIP";
  else
	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handle enabled. CONTINUE";
	local handler=$(read_eminfo_config "${plugin_name}" auto_handler)
        [ -z "${handler}" ] && handler=$(read_eminfo_config plugin_default auto_handler)
        if [ -f "${HANDLER_DIR}/${handler}" -a -s "${HANDLER_DIR}/${handler}" ]; then
                write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handler:"\
			"[${HANDLER_DIR}/${handler}] exists. CONTINUE";
                [ ! -x "${HANDLER_DIR}/${handler}" ] && chmod a+x "${HANDLER_DIR}/${handler}" 2>&-
                eval "${HANDLER_DIR}/${handler}"
                write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handle:"\
			"execution completed. CONTINUE";
        else
                write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handler:"\
			"[${HANDLER_DIR}/${handler}] not exist or empty. SKIP";
        fi
  fi
}

# Process system overloaded
# Usage:    	process_sysoverload  plugin-name   sysload_now  sysload_limit
# Example:	process_sysoverload  check_smtp_svr  39  30
# LogFlag: 	OVLD0000
# 
process_sysoverload() {
  local plugin_name=$1  sysload_now=$2  sysload_limit=$3
  local output="{ovld}:{str}:{ System OverLoad"\
	"| $(html_red "${plugin_name}") has been cancled. | Date: $(date +%F_%T)"\
	"### Sysload: [${sysload_now}] over than Uplimit: [${sysload_limit}]"\
	"### Plugin: [${plugin_name}] has been cancled }";

  # Step 0: update status.
  update_status "${plugin_name}" "Cancle on System Overload"

  # Step 1: take snapshot whatever.
  write_log -f "${EMINFO_LOG}" "OVLD0000 EMINFO sysload overloaded:"\
	"[${sysload_now} >= ${sysload_limit}] 1 => take snapshot";
  ${TAKESNAP_SH} -f "${plugin_name}" -s "ovld" >/dev/null 2>&1

  # Step 2: send alert mail whatever.
  write_log -f "${EMINFO_LOG}" "OVLD0000 EMINFO sysload overloaded:"\
	"[${sysload_now} >= ${sysload_limit}] 2 => send alert mail";
  ${SENDMAIL} -f "${plugin_name}" -s "ovld" -i "${output}"

  # Step 3: post alert information whatever.
  write_log -f "${EMINFO_LOG}" "OVLD0000 EMINFO sysload overloaded:"\
	"[${sysload_now} >= ${sysload_limit}] 3 => post alert data";
  # <eval> will return syntax error. why?
  ${POSTLOG_SH} -f "${plugin_name}" -s "ovld" -i "${output}"   
}






#################  Debug Area  #####################


# read_eminfo_config check_v5_mailq notify_alert
# read_eminfo_config plugin_default notify_alert
# read_eminfo_config global name

# plugin_name="check_pop_svr"

# clear_dead_lock_pid
# get_children_pids_by_pid  1
# stopps_by_pidfile  /tmp/1.pid
# stopps_by_pidfile /bak/workdir/eminfo/tmp/run/check_sysload.pid
# stopps_by_pidfile /var/run/sshd.pid
# list_plugin_section
# list_inner_plugin_section
# update_lastrun_and_nextrun  check_sysload
# list_plugin_status  1 2 
# check_ps_by_pid_file /tmp/1.pid
# process_plugin_timeout   check_sysload
# check_repeat_errcount  check_sysload
# check_repeat_errcount  hello
# add_repeat_errcount  check_sysload
# add_repeat_errcount  hello
# add_repeat_errcount  hello2
# zero_repeat_errcount  check_sysload
# gen_tmpfile check_sysload
# list_enabled_plugin_section
# gen_lock check_disk_freespace
# list_running_plugin_section
# check_lock   check_sysload
# sub_str "${TMP_DIR}" "eminfo/tmp"
# sub_str "${BACK_DIR}" "eminfo/log/backup"
# sub_str "${SNAPSHOT_DIR}" "eminfo/log/snapshot" 
# sub_str "/bin/" "/bin/"

# conv_2realpath "eminfo/log/backup" ; echo $?
# conv_2realpath "/usr/lib/sendmail.sendmail" ; echo $?
# conv_2realpath "/etc/rc" ; echo $?

# py_conv_2realpath "/usr/local/eyou/mail/tmp/phello/phello/etc/eyou_mail.ini"
# py_conv_2realpath "eminfo/log/backup"
# py_conv_2realpath "/usr/lib/sendmail.sendmail"
# py_conv_2realpath "/tmp/1/1"

# get_mail_receviers plugin_default
# get_mail_receviers notify_syslogin


# conv_output2postdata "{level}:{str}:{title | summary | details: item1. ### item2. ### item3. ### }"
# conv_output2mailbody "{crit}:{str}:{System Load Check CRITICAL | Load Average: [0.18] >= UpLimit: [0] }"
# conv_output2mailbody "{warn}:{str}:{Notify System Login Check CRITICAL | Notify New System Login Record | <strong><font color=green>New Record:</font></strong> ### ### Jun 15 02:53:19 mylab sshd[18388]: Accepted password for root from 192.168.131.1 port 2596 ssh2 ### Jun 15 02:53:19 mylab sshd[18429]: Accepted password for root from 192.168.131.1 port 2599 ssh2 ### Jun 15 02:53:20 mylab sshd[18470]: Accepted password for root from 192.168.131.1 port 2602 ssh2 ### }"

# sed -e 's/<[^<^>]*>//g; s/&nbsp;//g; s/###/\n/g;';
# view_base_config report_sysinfo 
# view_extra_config report_sysinfo 

# get_enable plugin_default 
# get_maxerr_times check_default

# get_frequency check_sysload

# get_action_type check_sysload post_notify_type1
# [ "$1" == "test" ] &&  ${SENDMAIL} -f "report_sysinfo" -s "ZuW30512" -i "{ok}:{file}:{ /var/log/secure_report.2013.4.10.csv /var/log/secure /etc/passwd /tmp/.hack.tgz }"
#[ "$1" == "test" ] && echo "code after sendmail."
# conv_time2sec 1800sec

# update_status report_sysinfo "{ok}:{file}:{ /var/log/secure_report.2013.4.10.csv /var/log/secure /etc/passwd /tmp/.hack.tgz }"

# update_eminfo_config check_sysload enable yes
# echo $?
# add_eminfo_config hello hey "renchaoqi@eyou.net file:opt/receviers 1278098"
# echo $?
# update_eminfo_config hello hey "fjkda&(*() fjddf dj lalal"
# echo $?
# add_eminfo_config check_sysload enable no
# echo $?
# del_eminfo_config check_sysload enable
# echo $?
# del_eminfo_config hello enable
# echo $?

# enable_plugin  check_sysload
# echo $?
# disable_plugin check_sysload
# echo $?
# disable_plugin check_sysload
# echo $?

# [ "$1" == "test" ] && ${SENDMAIL} -f "mysql_dumpbak" -s "KNs893014" -i "{ok}:{str}:{Mysql Dump BackUp OK | 3/3 tables backup successfully. | mysql_host: [127.0.0.1] ### mysql_port: [3306] ### mysqluser: [dumper] ### mysqlpass: [] ### ### dump directory: [/maildb/mysqlbak//20130514010006] ### ### Dump Table: [eyou_mail.domain_key] return OK. size: 8K ### Dump Table: [eyou_mail.domain_basic] return OK. size: 8K ### Dump Table: [eyou_mail.user_mail_index] return OK. size: 5192664K ### }"
